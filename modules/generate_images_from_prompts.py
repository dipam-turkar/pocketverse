"""
Script to generate images from prompts using Nano Banana.
Uses prompts generated by the post generation engine.
"""

import sys
import json
import time
from pathlib import Path
from typing import List, Dict

# Add parent directory to path
sys.path.insert(0, str(Path(__file__).parent.parent))

from modules.post_generation_engine import create_engine
from modules.nano_banana_client import create_nano_banana_client

# ============================================================================
# CONFIGURATION
# ============================================================================

# PromoCanon directory
CANON_DIRECTORY = "PromoCanon_Show_33adb096b04ecd6b23ce9341160b199f2d489311_1_100"

# Generation mode: Choose one of the following:
#   "episode" - Generate for specific episode(s)
#   "character" - Generate from character perspective
#   "top_engaging" - Get top N most engaging
#   "episode_range" - Generate for episode range
GENERATION_MODE = "character"

# Settings for "episode" mode
EPISODE_NUM = 7  # Episode number to generate
EPISODE_CHARACTER = None  # Character perspective (None for generic, or "Nora Smith", etc.)
PROMPTS_PER_CLIFFHANGER = 3  # Number of prompts to generate per cliffhanger

# Settings for "character" mode
CHARACTER_NAME = "Nora Smith"  # Character name
CHARACTER_MIN_EPISODE = 1
CHARACTER_MAX_EPISODE = 20
CHARACTER_LIMIT = 5

# Settings for "top_engaging" mode
TOP_COUNT = 5  # Number of prompts to generate
TOP_MIN_EPISODE = 1
TOP_MAX_EPISODE = 20

# Settings for "episode_range" mode
RANGE_START = 1
RANGE_END = 10
RANGE_CHARACTERS_PER_CLIFFHANGER = 1

# Nano Banana settings
GCP_PROJECT_ID = None  # Uses from creds.py if None
GCP_REGION = "us-central1"
IMAGE_WIDTH = 1024
IMAGE_HEIGHT = 1024
IMAGE_STYLE = "cinematic"  # Optional style parameter

# GCS settings (optional - for storing generated images)
GCS_BUCKET_NAME = None  # Set to bucket name if you want to upload to GCS
GCS_UPLOAD = False  # Set to True to upload images to GCS

# Disk storage settings
SAVE_TO_DISK = True  # Set to True to save images to disk
IMAGES_DIR = "generated_images"  # Directory to save images
IMAGE_FILENAME_FORMAT = "episode_{episode}_{perspective}_{timestamp}.png"  # Filename format

# Output settings
SAVE_RESULTS = True
RESULTS_FILE = "generated_images.json"
MAX_IMAGES_TO_GENERATE = 3  # Limit for testing


def generate_images_from_prompts():
    """Generate images from prompts"""
    print("="*80)
    print("NANO BANANA IMAGE GENERATION")
    print("="*80)
    print(f"Canon Directory: {CANON_DIRECTORY}")
    print(f"Generation Mode: {GENERATION_MODE}")
    print(f"Max images to generate: {MAX_IMAGES_TO_GENERATE}")
    print(f"Image size: {IMAGE_WIDTH}x{IMAGE_HEIGHT}")
    print("="*80)
    
    # Initialize post generation engine
    try:
        print("\n1. Initializing post generation engine...")
        engine = create_engine(CANON_DIRECTORY)
        print("   ✓ Engine initialized")
        print(f"   ✓ Available characters: {', '.join(engine.get_available_characters())}")
    except Exception as e:
        print(f"   ✗ Error: {e}")
        return
    
    # Generate prompts based on mode
    try:
        if GENERATION_MODE == "episode":
            print(f"\n2. Generating prompts for Episode {EPISODE_NUM}...")
            if EPISODE_CHARACTER:
                print(f"   Character perspective: {EPISODE_CHARACTER}")
            print(f"   Prompts per cliffhanger: {PROMPTS_PER_CLIFFHANGER}")
            prompts = engine.generate_prompts_for_cliffhanger(
                episode_num=EPISODE_NUM,
                perspective_character=EPISODE_CHARACTER,
                prompts_per_cliffhanger=PROMPTS_PER_CLIFFHANGER
            )
        
        elif GENERATION_MODE == "character":
            print(f"\n2. Generating prompts from {CHARACTER_NAME}'s perspective...")
            print(f"   Episode range: {CHARACTER_MIN_EPISODE}-{CHARACTER_MAX_EPISODE}")
            print(f"   Limit: {CHARACTER_LIMIT}")
            prompts = engine.generate_prompts_for_character(
                character_name=CHARACTER_NAME,
                min_episode=CHARACTER_MIN_EPISODE,
                max_episode=CHARACTER_MAX_EPISODE,
                limit=CHARACTER_LIMIT
            )
        
        elif GENERATION_MODE == "top_engaging":
            print(f"\n2. Generating top {TOP_COUNT} most engaging prompts...")
            print(f"   Episode range: {TOP_MIN_EPISODE}-{TOP_MAX_EPISODE}")
            prompts = engine.generate_top_engaging_prompts(
                count=TOP_COUNT,
                min_episode=TOP_MIN_EPISODE,
                max_episode=TOP_MAX_EPISODE
            )
        
        elif GENERATION_MODE == "episode_range":
            print(f"\n2. Generating prompts for episodes {RANGE_START}-{RANGE_END}...")
            print(f"   Characters per cliffhanger: {RANGE_CHARACTERS_PER_CLIFFHANGER}")
            prompts = engine.generate_prompts_for_episode_range(
                start_episode=RANGE_START,
                end_episode=RANGE_END,
                characters_per_cliffhanger=RANGE_CHARACTERS_PER_CLIFFHANGER
            )
        
        else:
            print(f"\n   ✗ Unknown generation mode: {GENERATION_MODE}")
            print("   Valid modes: 'episode', 'character', 'top_engaging', 'episode_range'")
            return
        
        print(f"   ✓ Generated {len(prompts)} prompts")
        
        if not prompts:
            print("   ⚠ No prompts generated. Exiting.")
            return
        
        # Limit to max images
        prompts = prompts[:MAX_IMAGES_TO_GENERATE]
        print(f"   → Using first {len(prompts)} prompts for image generation")
        
    except Exception as e:
        print(f"   ✗ Error generating prompts: {e}")
        import traceback
        traceback.print_exc()
        return
    
    # Initialize Nano Banana client
    try:
        print("\n3. Initializing Nano Banana client...")
        client = create_nano_banana_client(
            project_id=GCP_PROJECT_ID,
            region=GCP_REGION
        )
        print("   ✓ Client initialized")
    except Exception as e:
        print(f"   ✗ Error initializing client: {e}")
        import traceback
        traceback.print_exc()
        return
    
    # Generate images
    print(f"\n4. Generating {len(prompts)} images...")
    print("   (This may take a few seconds per image)")
    print("-"*80)
    
    results = []
    
    for i, prompt_data in enumerate(prompts, 1):
        prompt_text = prompt_data.get('prompt', '')
        episode = prompt_data.get('episode', 'Unknown')
        perspective = prompt_data.get('perspective_character', 'Generic')
        
        print(f"\n   Image {i}/{len(prompts)}")
        print(f"   Episode: {episode}")
        print(f"   Perspective: {perspective}")
        print(f"   Prompt: {prompt_text}...")
        
        try:
            # Generate image
            result = client.generate_image(
                prompt=prompt_text,
                width=IMAGE_WIDTH,
                height=IMAGE_HEIGHT,
                style=IMAGE_STYLE
            )
            
            if result.get('status') == 'completed':
                image_url = result.get('image_url')
                image_id = result.get('image_id')
                
                print(f"   ✓ Image generated successfully")
                print(f"   Image ID: {image_id}")
                if image_url and image_url.startswith("data:image"):
                    print(f"   Image format: Base64 data URL (saved to disk)")
                else:
                    print(f"   Image URL: {image_url[:100]}..." if image_url and len(image_url) > 100 else f"   Image URL: {image_url}")
                
                # Extract base64 data from data URL if present
                image_base64 = None
                if image_url and image_url.startswith("data:image"):
                    # Extract base64 part from data URL
                    image_base64 = image_url.split(",")[1] if "," in image_url else None
                
                # Save to disk if configured
                disk_path = None
                if SAVE_TO_DISK and image_base64:
                    try:
                        import os
                        from pathlib import Path
                        
                        # Create images directory
                        images_dir = Path(IMAGES_DIR)
                        images_dir.mkdir(parents=True, exist_ok=True)
                        
                        # Generate filename
                        timestamp = int(time.time())
                        safe_perspective = perspective.replace(" ", "_").replace("/", "_") if perspective else "generic"
                        filename = f"episode_{episode}_{safe_perspective}_{timestamp}.png"
                        filepath = images_dir / filename
                        
                        print(f"   Saving to disk...")
                        disk_path = client.save_image_to_disk(
                            image_base64=image_base64,
                            filepath=str(filepath)
                        )
                        print(f"   ✓ Saved to: {disk_path}")
                    except Exception as e:
                        print(f"   ⚠ Disk save failed: {e}")
                
                # Upload to GCS if configured
                gcs_url = None
                if GCS_UPLOAD and GCS_BUCKET_NAME and image_base64:
                    try:
                        print(f"   Uploading to GCS...")
                        blob_name = f"images/episode_{episode}/{image_id}.png"
                        gcs_url = client.upload_to_gcs(
                            image_base64=image_base64,
                            bucket_name=GCS_BUCKET_NAME,
                            blob_name=blob_name
                        )
                        print(f"   ✓ Uploaded to: {gcs_url}")
                    except Exception as e:
                        print(f"   ⚠ GCS upload failed: {e}")
                
                # Store result
                image_result = {
                    'prompt_data': prompt_data,
                    'image_id': image_id,
                    'image_url': image_url,
                    'disk_path': disk_path,
                    'gcs_url': gcs_url,
                    'status': 'completed',
                    'generated_at': time.time()
                }
                results.append(image_result)
                
            elif result.get('status') == 'error':
                print(f"   ✗ Error: {result.get('error')}")
                results.append({
                    'prompt_data': prompt_data,
                    'status': 'error',
                    'error': result.get('error'),
                    'generated_at': time.time()
                })
            else:
                print(f"   ⚠ Unexpected status: {result.get('status')}")
                results.append({
                    'prompt_data': prompt_data,
                    'status': result.get('status'),
                    'generated_at': time.time()
                })
                
        except Exception as e:
            print(f"   ✗ Exception: {e}")
            import traceback
            traceback.print_exc()
            results.append({
                'prompt_data': prompt_data,
                'status': 'exception',
                'error': str(e),
                'generated_at': time.time()
            })
        
        # Small delay between requests
        if i < len(prompts):
            print("   Waiting 1 second before next image...")
            time.sleep(1)
    
    # Save results
    if SAVE_RESULTS and results:
        print(f"\n5. Saving results to {RESULTS_FILE}...")
        try:
            # Build config based on generation mode
            config = {
                'canon_directory': CANON_DIRECTORY,
                'generation_mode': GENERATION_MODE,
                'max_images': MAX_IMAGES_TO_GENERATE,
                'image_size': f"{IMAGE_WIDTH}x{IMAGE_HEIGHT}"
            }
            
            if GENERATION_MODE == "episode":
                config.update({
                    'episode_num': EPISODE_NUM,
                    'episode_character': EPISODE_CHARACTER,
                    'prompts_per_cliffhanger': PROMPTS_PER_CLIFFHANGER
                })
            elif GENERATION_MODE == "character":
                config.update({
                    'character_name': CHARACTER_NAME,
                    'character_min_episode': CHARACTER_MIN_EPISODE,
                    'character_max_episode': CHARACTER_MAX_EPISODE,
                    'character_limit': CHARACTER_LIMIT
                })
            elif GENERATION_MODE == "top_engaging":
                config.update({
                    'top_count': TOP_COUNT,
                    'top_min_episode': TOP_MIN_EPISODE,
                    'top_max_episode': TOP_MAX_EPISODE
                })
            elif GENERATION_MODE == "episode_range":
                config.update({
                    'range_start': RANGE_START,
                    'range_end': RANGE_END,
                    'range_characters_per_cliffhanger': RANGE_CHARACTERS_PER_CLIFFHANGER
                })
            
            output_data = {
                'generation_config': config,
                'results': results,
                'summary': {
                    'total': len(results),
                    'completed': len([r for r in results if r.get('status') == 'completed']),
                    'failed': len([r for r in results if r.get('status') in ['error', 'exception']])
                }
            }
            
            with open(RESULTS_FILE, 'w', encoding='utf-8') as f:
                json.dump(output_data, f, indent=2, ensure_ascii=False)
            
            print(f"   ✓ Results saved")
        except Exception as e:
            print(f"   ⚠ Failed to save results: {e}")
    
    # Summary
    print("\n" + "="*80)
    print("SUMMARY")
    print("="*80)
    print(f"Total images attempted: {len(results)}")
    print(f"Completed: {len([r for r in results if r.get('status') == 'completed'])}")
    print(f"Failed: {len([r for r in results if r.get('status') in ['error', 'exception']])}")
    print("="*80)
    
    # Print image summary (without base64 data)
    completed = [r for r in results if r.get('status') == 'completed']
    if completed:
        print("\nGenerated Images Summary:")
        for i, result in enumerate(completed, 1):
            print(f"\n  {i}. Episode {result['prompt_data'].get('episode')} - {result['prompt_data'].get('perspective_character', 'Generic')}")
            print(f"     Image ID: {result.get('image_id')}")
            if result.get('disk_path'):
                print(f"     Saved to: {result.get('disk_path')}")
            if result.get('gcs_url'):
                print(f"     GCS: {result.get('gcs_url')}")
            # Don't print base64 data URLs - they're too long and clutter output


if __name__ == "__main__":
    generate_images_from_prompts()
